// convex/lib/yourobc/accounting/outgoing_invoices/queries.ts
// convex/lib/accounting/outgoing-invoices/queries.ts

import { v } from 'convex/values'
import { query } from '@/generated/server'
import { getExchangeRateForInvoice } from '../shared/exchange_rate_helpers'

/**
 * Preview next invoice number
 */
export const previewNextInvoiceNumber = query({
  args: {},
  handler: async (ctx) => {
    const now = new Date()
    const year = now.getFullYear()
    const month = now.getMonth() + 1

    // Get numbering record for this month
    const numbering = await ctx.db
      .query('yourobcInvoiceNumbering')
      .withIndex('by_year_month', (q) => q.eq('year', year).eq('month', month))
      .first()

    let nextNumber: number
    if (!numbering) {
      nextNumber = 13 // First invoice starts at 13
    } else {
      nextNumber = numbering.lastNumber + numbering.incrementBy
    }

    // Format: YYMM0013
    const yy = year.toString().slice(-2)
    const mm = month.toString().padStart(2, '0')
    const num = nextNumber.toString().padStart(4, '0')

    return {
      invoiceNumber: `${yy}${mm}${num}`,
      year,
      month,
      number: nextNumber,
    }
  },
})

/**
 * Get invoice numbering history
 */
export const getInvoiceNumberingHistory = query({
  args: {
    year: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let query = ctx.db.query('yourobcInvoiceNumbering')

    if (args.year) {
      const allRecords = await query.collect()
      return allRecords.filter((r) => r.year === args.year).sort((a, b) => b.month - a.month)
    }

    const records = await query.order('desc').take(12) // Last 12 months
    return records
  },
})

/**
 * Get auto-generated invoices log
 */
export const getAutoGeneratedInvoices = query({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit || 50

    const logs = await ctx.db
      .query('yourobcInvoiceAutoGenLog')
      .withIndex('by_generatedDate', (q) => q.gte('generatedDate', 0))
      .order('desc')
      .take(limit)

    // Enrich with shipment and invoice details
    const enriched = await Promise.all(
      logs.map(async (log) => {
        const shipment = await ctx.db.get(log.shipmentId)
        const invoice = await ctx.db.get(log.invoiceId)

        return {
          ...log,
          shipment: shipment
            ? {
                _id: shipment._id,
                shipmentNumber: shipment.shipmentNumber,
                // Customer name would need to be fetched from customer record
              }
            : null,
          invoice: invoice
            ? {
                _id: invoice._id,
                invoiceNumber: invoice.invoiceNumber,
                totalAmount: invoice.totalAmount,
                status: invoice.status,
              }
            : null,
        }
      })
    )

    return enriched
  },
})

/**
 * Get pending notification invoices
 */
export const getPendingNotifications = query({
  args: {},
  handler: async (ctx) => {
    const pendingLogs = await ctx.db
      .query('yourobcInvoiceAutoGenLog')
      .filter((q) => q.eq(q.field('notificationSent'), false))
      .collect()

    // Enrich with details
    const enriched = await Promise.all(
      pendingLogs.map(async (log) => {
        const invoice = await ctx.db.get(log.invoiceId)
        const shipment = await ctx.db.get(log.shipmentId)

        return {
          ...log,
          invoice: invoice
            ? {
                _id: invoice._id,
                invoiceNumber: invoice.invoiceNumber,
                totalAmount: invoice.totalAmount,
              }
            : null,
          shipment: shipment
            ? {
                _id: shipment._id,
                shipmentNumber: shipment.shipmentNumber,
              }
            : null,
        }
      })
    )

    return enriched
  },
})

/**
 * Get exchange rate for date
 */
export const getExchangeRate = query({
  args: {
    fromCurrency: v.union(v.literal('EUR'), v.literal('USD')),
    toCurrency: v.union(v.literal('EUR'), v.literal('USD')),
    date: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    // Same currency
    if (args.fromCurrency === args.toCurrency) {
      return { rate: 1, date: args.date || Date.now(), source: 'same_currency' }
    }

    const targetDate = args.date || Date.now()
    const searchDate = new Date(targetDate)
    searchDate.setHours(0, 0, 0, 0)
    const searchTimestamp = searchDate.getTime()

    // Try to find exact date
    const exactRate = await ctx.db
      .query('yourobcExchangeRates')
      .withIndex('by_date', (q) => q.eq('date', searchTimestamp))
      .filter((q) =>
        q.and(
          q.eq(q.field('fromCurrency'), args.fromCurrency),
          q.eq(q.field('toCurrency'), args.toCurrency)
        )
      )
      .first()

    if (exactRate) {
      return {
        rate: exactRate.rate,
        date: exactRate.date,
        source: 'exact_date',
      }
    }

    // Find nearest rate
    const allRates = await ctx.db
      .query('yourobcExchangeRates')
      .filter((q) =>
        q.and(
          q.eq(q.field('fromCurrency'), args.fromCurrency),
          q.eq(q.field('toCurrency'), args.toCurrency)
        )
      )
      .order('desc')
      .take(1)

    if (allRates.length > 0) {
      return {
        rate: allRates[0].rate,
        date: allRates[0].date,
        source: 'nearest_date',
      }
    }

    // Default rate
    const defaultRate = args.fromCurrency === 'EUR' ? 1.1 : 0.91
    return {
      rate: defaultRate,
      date: searchTimestamp,
      source: 'default',
    }
  },
})

/**
 * Calculate currency conversion preview
 */
export const previewCurrencyConversion = query({
  args: {
    amount: v.number(),
    fromCurrency: v.union(v.literal('EUR'), v.literal('USD')),
    toCurrency: v.union(v.literal('EUR'), v.literal('USD')),
    date: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    if (args.fromCurrency === args.toCurrency) {
      return {
        originalAmount: args.amount,
        convertedAmount: args.amount,
        currency: args.toCurrency,
        rate: 1,
        date: args.date || Date.now(),
      }
    }

    const rateInfo = await getExchangeRateForInvoice(ctx.db, args.fromCurrency, args.toCurrency, args.date)

    const convertedAmount = args.amount * rateInfo.rate

    return {
      originalAmount: args.amount,
      originalCurrency: args.fromCurrency,
      convertedAmount,
      currency: args.toCurrency,
      rate: rateInfo.rate,
      date: rateInfo.date,
      source: rateInfo.source,
    }
  },
})

/**
 * Get outgoing invoices summary
 */
export const getOutgoingInvoicesSummary = query({
  args: {
    startDate: v.optional(v.number()),
    endDate: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let invoices = await ctx.db
      .query('yourobcInvoices')
      .withIndex('by_type', (q) => q.eq('type', 'outgoing'))
      .collect()

    // Filter by date range
    if (args.startDate || args.endDate) {
      invoices = invoices.filter((inv) => {
        if (args.startDate && inv.issueDate < args.startDate) return false
        if (args.endDate && inv.issueDate > args.endDate) return false
        return true
      })
    }

    const summary = {
      total: invoices.length,
      draft: 0,
      sent: 0,
      paid: 0,
      overdue: 0,
      cancelled: 0,
      totalValue: {
        EUR: 0,
        USD: 0,
      },
      paidValue: {
        EUR: 0,
        USD: 0,
      },
      overdueValue: {
        EUR: 0,
        USD: 0,
      },
    }

    invoices.forEach((inv) => {
      // Count by status
      summary[inv.status]++

      // Sum values by currency
      const currency = inv.totalAmount.currency
      const amount = inv.totalAmount.amount

      summary.totalValue[currency] += amount

      if (inv.status === 'paid') {
        summary.paidValue[currency] += amount
      } else if (inv.status === 'overdue') {
        summary.overdueValue[currency] += amount
      }
    })

    return summary
  },
})

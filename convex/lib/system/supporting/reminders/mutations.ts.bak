// convex/lib/system/supporting/reminders/mutations.ts

/**
 * Reminders Module Mutations
 * Write operations for creating, updating, and managing reminders
 */
import { mutation } from '@/generated/server'
import { v } from 'convex/values'
import { requireCurrentUser, requireOwnershipOrAdmin } from '@/shared/auth.helper'
import { entityTypes } from '../../audit_logs/entityTypes'
import { reminderTypeValidator, reminderStatusValidator, recurrenceFrequencyValidator } from '@/schema/base'
import {
  validateCreateReminderData,
  validateUpdateReminderData,
  validateCompleteReminderData,
  validateSnoozeReminderData,
} from './utils'
import { calculateNextOccurrence } from '@/shared/utils'

/**
 * Create a new reminder
 */
export const createReminder = mutation({
  args: {
    
    data: v.object({
      title: v.string(),
      description: v.optional(v.string()),
      type: reminderTypeValidator,
      entityType: entityTypes.all,
      entityId: v.string(),
      dueDate: v.number(),
      reminderDate: v.optional(v.number()),
      priority: v.optional(v.union(v.literal('low'), v.literal('medium'), v.literal('high'), v.literal('urgent'))),
      assignedTo: v.id('userProfiles'),
      emailReminder: v.optional(v.boolean()),
      isRecurring: v.optional(v.boolean()),
      recurrencePattern: v.optional(v.object({
        frequency: recurrenceFrequencyValidator,
        interval: v.number(),
        endDate: v.optional(v.number()),
        maxOccurrences: v.optional(v.number()),
      })),
    })
  },
  handler: async (ctx, { data }) => {
    const user = await requireCurrentUser(ctx)

    const errors = validateCreateReminderData(data)
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(', ')}`)
    }

    const now = Date.now()

    const reminderData: any = {
      title: data.title.trim(),
      description: data.description?.trim(),
      type: data.type,
      entityType: data.entityType,
      entityId: data.entityId,
      dueDate: data.dueDate,
      reminderDate: data.reminderDate,
      priority: data.priority || 'medium',
      assignedTo: data.assignedTo,
      assignedBy: user._id,
      status: 'pending' as const,
      emailReminder: data.emailReminder ?? true,
      createdAt: now,
      createdBy: user._id,
    }

    // Add recurrence if provided
    if (data.isRecurring && data.recurrencePattern) {
      reminderData.isRecurring = true
      reminderData.recurrencePattern = data.recurrencePattern
    }

    return await ctx.db.insert('reminders', reminderData)
  },
})

/**
 * Update an existing reminder
 */
export const updateReminder = mutation({
  args: {
    
    reminderId: v.id('reminders'),
    data: v.object({
      title: v.optional(v.string()),
      description: v.optional(v.string()),
      type: v.optional(reminderTypeValidator),
      dueDate: v.optional(v.number()),
      reminderDate: v.optional(v.number()),
      priority: v.optional(v.union(v.literal('low'), v.literal('medium'), v.literal('high'), v.literal('urgent'))),
      assignedTo: v.optional(v.id('userProfiles')),
      emailReminder: v.optional(v.boolean()),
    })
  },
  handler: async (ctx, { reminderId, data }) => {
    const user = await requireCurrentUser(ctx)

    const reminder = await ctx.db.get(reminderId)
    if (!reminder || reminder.deletedAt) {
      throw new Error('Reminder not found')
    }

    const errors = validateUpdateReminderData(data)
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(', ')}`)
    }

    const now = Date.now()
    const updateData: Record<string, unknown> = {
      updatedAt: now,
      updatedBy: user._id,
    }

    if (data.title !== undefined) {
      updateData.title = data.title.trim()
    }

    if (data.description !== undefined) {
      updateData.description = data.description.trim()
    }

    if (data.type !== undefined) {
      updateData.type = data.type
    }

    if (data.dueDate !== undefined) {
      updateData.dueDate = data.dueDate
    }

    if (data.reminderDate !== undefined) {
      updateData.reminderDate = data.reminderDate
    }

    if (data.priority !== undefined) {
      updateData.priority = data.priority
    }

    if (data.assignedTo !== undefined) {
      updateData.assignedTo = data.assignedTo
    }

    if (data.emailReminder !== undefined) {
      updateData.emailReminder = data.emailReminder
    }

    await ctx.db.patch(reminderId, updateData)
    return reminderId
  },
})

/**
 * Complete a reminder
 */
export const completeReminder = mutation({
  args: {
    
    reminderId: v.id('reminders'),
    completionNotes: v.optional(v.string()),
  },
  handler: async (ctx, { reminderId, completionNotes }) => {
    const user = await requireCurrentUser(ctx)

    const reminder = await ctx.db.get(reminderId)
    if (!reminder || reminder.deletedAt) {
      throw new Error('Reminder not found')
    }

    const errors = validateCompleteReminderData({ completionNotes })
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(', ')}`)
    }

    const now = Date.now()

    // If recurring, create next occurrence
    if (reminder.isRecurring && reminder.recurrencePattern) {
      const pattern = reminder.recurrencePattern

      // Check if we should create next occurrence
      const shouldCreateNext =
        (!pattern.endDate || now < pattern.endDate) &&
        (!pattern.maxOccurrences || (reminder.metadata?.occurrenceCount || 0) < pattern.maxOccurrences)

      if (shouldCreateNext) {
        // Adapt reminder to ScheduledEvent format for calculateNextOccurrence
        const eventAdapter = {
          startTime: reminder.dueDate,
          isRecurring: reminder.isRecurring,
          recurrencePattern: reminder.recurrencePattern,
        }
        const nextDueDate = calculateNextOccurrence(eventAdapter as any)

        if (!nextDueDate) {
          // No more occurrences, don't create next reminder
          await ctx.db.patch(reminderId, {
            status: 'completed' as const,
            completedAt: now,
            completedBy: user._id,
            completionNotes: completionNotes?.trim(),
            updatedAt: now,
            updatedBy: user._id,
          })
          return reminderId
        }

        // Destructure to exclude system fields
        const { _id, _creationTime, completedAt: _completedAt, completedBy: _completedBy, completionNotes: _completionNotes, ...reminderData } = reminder

        await ctx.db.insert('reminders', {
          ...reminderData,
          dueDate: nextDueDate,
          status: 'pending' as const,
          completedAt: undefined,
          completedBy: undefined,
          completionNotes: undefined,
          createdAt: now,
          createdBy: user._id,
          metadata: {
            ...(reminder.metadata || {}),
            occurrenceCount: (reminder.metadata?.occurrenceCount || 0) + 1,
            previousReminderId: reminderId,
          },
        })
      }
    }

    // Complete current reminder
    await ctx.db.patch(reminderId, {
      status: 'completed' as const,
      completedAt: now,
      completedBy: user._id,
      completionNotes: completionNotes?.trim(),
      updatedAt: now,
      updatedBy: user._id,
    })

    return reminderId
  },
})

/**
 * Snooze a reminder
 */
export const snoozeReminder = mutation({
  args: {
    
    reminderId: v.id('reminders'),
    snoozeUntil: v.number(),
    snoozeReason: v.optional(v.string()),
  },
  handler: async (ctx, { reminderId, snoozeUntil, snoozeReason }) => {
    const user = await requireCurrentUser(ctx)

    const reminder = await ctx.db.get(reminderId)
    if (!reminder || reminder.deletedAt) {
      throw new Error('Reminder not found')
    }

    const errors = validateSnoozeReminderData({ snoozeUntil, snoozeReason })
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(', ')}`)
    }

    const now = Date.now()

    await ctx.db.patch(reminderId, {
      status: 'snoozed' as const,
      snoozeUntil,
      snoozeReason: snoozeReason?.trim(),
      snoozedBy: user._id,
      snoozedAt: now,
      updatedAt: now,
      updatedBy: user._id,
    })

    return reminderId
  },
})

/**
 * Cancel a reminder
 */
export const cancelReminder = mutation({
  args: {
    
    reminderId: v.id('reminders'),
  },
  handler: async (ctx, { reminderId }) => {
    const user = await requireCurrentUser(ctx)

    const reminder = await ctx.db.get(reminderId)
    if (!reminder || reminder.deletedAt) {
      throw new Error('Reminder not found')
    }

    const now = Date.now()

    await ctx.db.patch(reminderId, {
      status: 'cancelled' as const,
      updatedAt: now,
      updatedBy: user._id,
    })

    return reminderId
  },
})

/**
 * Delete a reminder (soft delete)
 */
export const deleteReminder = mutation({
  args: {
    
    reminderId: v.id('reminders'),
  },
  handler: async (ctx, { reminderId }) => {
    const user = await requireCurrentUser(ctx)

    const reminder = await ctx.db.get(reminderId)
    if (!reminder || reminder.deletedAt) {
      throw new Error('Reminder not found')
    }

    // Check if user created the reminder OR is admin/superadmin
    await requireOwnershipOrAdmin(ctx, reminder.createdBy)

    const now = Date.now()

    await ctx.db.patch(reminderId, {
      deletedAt: now,
      deletedBy: user._id,
      updatedAt: now,
      updatedBy: user._id,
    })

    return reminderId
  },
})
